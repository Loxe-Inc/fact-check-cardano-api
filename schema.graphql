schema {
  query: Query
  mutation: Mutation
}
"A date and time, represented as an ISO-8601 string"
scalar DateTime
type Query {
  tokenSets(where: TokenSetWhere, options: TokenSetOptions): [TokenSet!]!
  tokenSetsAggregate(where: TokenSetWhere): TokenSetAggregateSelection!
  tokenSetsConnection(first: Int, after: String, where: TokenSetWhere, sort: [TokenSetSort]): TokenSetsConnection!
  userLogins(where: UserLoginWhere, options: UserLoginOptions): [UserLogin!]!
  userLoginsAggregate(where: UserLoginWhere): UserLoginAggregateSelection!
  userLoginsConnection(first: Int, after: String, where: UserLoginWhere, sort: [UserLoginSort]): UserLoginsConnection!
  users(where: UserWhere, options: UserOptions): [User!]!
  usersAggregate(where: UserWhere): UserAggregateSelection!
  usersConnection(first: Int, after: String, where: UserWhere, sort: [UserSort]): UsersConnection!
  documents(where: DocumentWhere, options: DocumentOptions): [Document!]!
  documentsAggregate(where: DocumentWhere): DocumentAggregateSelection!
  documentsConnection(first: Int, after: String, where: DocumentWhere, sort: [DocumentSort]): DocumentsConnection!
  topics(where: TopicWhere, options: TopicOptions): [Topic!]!
  topicsAggregate(where: TopicWhere): TopicAggregateSelection!
  topicsConnection(first: Int, after: String, where: TopicWhere, sort: [TopicSort]): TopicsConnection!
  orgs(where: OrgWhere, options: OrgOptions): [Org!]!
  orgsAggregate(where: OrgWhere): OrgAggregateSelection!
  orgsConnection(first: Int, after: String, where: OrgWhere, sort: [OrgSort]): OrgsConnection!
  categories(where: CategoryWhere, options: CategoryOptions): [Category!]!
  categoriesAggregate(where: CategoryWhere): CategoryAggregateSelection!
  categoriesConnection(first: Int, after: String, where: CategoryWhere, sort: [CategorySort]): CategoriesConnection!
}
type Mutation {
  Login(email: String!, password: String!): UserLogin!
  CreateUser(email: String!, password: String!, name: String!): UserLogin!
  RefreshToken(refresh_token: String!): UserLogin!
  CreateDocuments(inputs: [DocumentCreateInput!]!): [Document!]!
  UpdateDocuments(inputs: [DocumentUpdateInput!]!): [Document!]!
  createTokenSets(input: [TokenSetCreateInput!]!): CreateTokenSetsMutationResponse!
  deleteTokenSets(where: TokenSetWhere): DeleteInfo!
  updateTokenSets(where: TokenSetWhere, update: TokenSetUpdateInput): UpdateTokenSetsMutationResponse!
  createUserLogins(input: [UserLoginCreateInput!]!): CreateUserLoginsMutationResponse!
  deleteUserLogins(where: UserLoginWhere): DeleteInfo!
  updateUserLogins(where: UserLoginWhere, update: UserLoginUpdateInput): UpdateUserLoginsMutationResponse!
  createUsers(input: [UserCreateInput!]!): CreateUsersMutationResponse!
  deleteUsers(where: UserWhere, delete: UserDeleteInput): DeleteInfo!
  updateUsers(where: UserWhere, update: UserUpdateInput, connect: UserConnectInput, disconnect: UserDisconnectInput, create: UserRelationInput, delete: UserDeleteInput, connectOrCreate: UserConnectOrCreateInput): UpdateUsersMutationResponse!
  createDocuments(input: [DocumentCreateInput!]!): CreateDocumentsMutationResponse!
  deleteDocuments(where: DocumentWhere, delete: DocumentDeleteInput): DeleteInfo!
  updateDocuments(where: DocumentWhere, update: DocumentUpdateInput, connect: DocumentConnectInput, disconnect: DocumentDisconnectInput, create: DocumentRelationInput, delete: DocumentDeleteInput, connectOrCreate: DocumentConnectOrCreateInput): UpdateDocumentsMutationResponse!
  createTopics(input: [TopicCreateInput!]!): CreateTopicsMutationResponse!
  deleteTopics(where: TopicWhere, delete: TopicDeleteInput): DeleteInfo!
  updateTopics(where: TopicWhere, update: TopicUpdateInput, connect: TopicConnectInput, disconnect: TopicDisconnectInput, create: TopicRelationInput, delete: TopicDeleteInput, connectOrCreate: TopicConnectOrCreateInput): UpdateTopicsMutationResponse!
  createOrgs(input: [OrgCreateInput!]!): CreateOrgsMutationResponse!
  deleteOrgs(where: OrgWhere): DeleteInfo!
  updateOrgs(where: OrgWhere, update: OrgUpdateInput): UpdateOrgsMutationResponse!
  createCategories(input: [CategoryCreateInput!]!): CreateCategoriesMutationResponse!
  deleteCategories(where: CategoryWhere, delete: CategoryDeleteInput): DeleteInfo!
  updateCategories(where: CategoryWhere, update: CategoryUpdateInput, connect: CategoryConnectInput, disconnect: CategoryDisconnectInput, create: CategoryRelationInput, delete: CategoryDeleteInput, connectOrCreate: CategoryConnectOrCreateInput): UpdateCategoriesMutationResponse!
}
type CategoriesConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [CategoryEdge!]!
}
type Category {
  createdBy: String!
  id: ID!
  name: String!
  topics(where: TopicWhere, options: TopicOptions, directed: Boolean = true): [Topic!]!
  topicsAggregate(where: TopicWhere, directed: Boolean = true): CategoryTopicTopicsAggregationSelection
  topicsConnection(where: CategoryTopicsConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [CategoryTopicsConnectionSort!]): CategoryTopicsConnection!
}
type CategoryAggregateSelection {
  count: Int!
  createdBy: StringAggregateSelectionNonNullable!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type CategoryEdge {
  cursor: String!
  node: Category!
}
type CategoryTopicsConnection {
  edges: [CategoryTopicsRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type CategoryTopicsRelationship {
  cursor: String!
  node: Topic!
}
type CategoryTopicTopicsAggregationSelection {
  count: Int!
  node: CategoryTopicTopicsNodeAggregateSelection
}
type CategoryTopicTopicsNodeAggregateSelection {
  createdBy: StringAggregateSelectionNonNullable!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type CreateCategoriesMutationResponse {
  info: CreateInfo!
  categories: [Category!]!
}
type CreateDocumentsMutationResponse {
  info: CreateInfo!
  documents: [Document!]!
}
type CreateInfo {
  bookmark: String
  nodesCreated: Int!
  relationshipsCreated: Int!
}
type CreateOrgsMutationResponse {
  info: CreateInfo!
  orgs: [Org!]!
}
type CreateTokenSetsMutationResponse {
  info: CreateInfo!
  tokenSets: [TokenSet!]!
}
type CreateTopicsMutationResponse {
  info: CreateInfo!
  topics: [Topic!]!
}
type CreateUserLoginsMutationResponse {
  info: CreateInfo!
  userLogins: [UserLogin!]!
}
type CreateUsersMutationResponse {
  info: CreateInfo!
  users: [User!]!
}
type DateTimeAggregateSelectionNonNullable {
  min: DateTime!
  max: DateTime!
}
type DeleteInfo {
  bookmark: String
  nodesDeleted: Int!
  relationshipsDeleted: Int!
}
type Document {
  id: ID!
  title: String!
  text: String!
  url: String!
  verified: Boolean!
  deleted: Boolean!
  createdOn: DateTime!
  updatedOn: DateTime!
  topic(where: TopicWhere, options: TopicOptions, directed: Boolean = true): Topic!
  topicAggregate(where: TopicWhere, directed: Boolean = true): DocumentTopicTopicAggregationSelection
  createdBy(where: UserWhere, options: UserOptions, directed: Boolean = true): User!
  createdByAggregate(where: UserWhere, directed: Boolean = true): DocumentUserCreatedByAggregationSelection
  topicConnection(where: DocumentTopicConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [DocumentTopicConnectionSort!]): DocumentTopicConnection!
  createdByConnection(where: DocumentCreatedByConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [DocumentCreatedByConnectionSort!]): DocumentCreatedByConnection!
}
type DocumentAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNonNullable!
  title: StringAggregateSelectionNonNullable!
  text: StringAggregateSelectionNonNullable!
  url: StringAggregateSelectionNonNullable!
  createdOn: DateTimeAggregateSelectionNonNullable!
  updatedOn: DateTimeAggregateSelectionNonNullable!
}
type DocumentCreatedByConnection {
  edges: [DocumentCreatedByRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type DocumentCreatedByRelationship {
  cursor: String!
  node: User!
}
type DocumentEdge {
  cursor: String!
  node: Document!
}
type DocumentsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [DocumentEdge!]!
}
type DocumentTopicConnection {
  edges: [DocumentTopicRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type DocumentTopicRelationship {
  cursor: String!
  node: Topic!
}
type DocumentTopicTopicAggregationSelection {
  count: Int!
  node: DocumentTopicTopicNodeAggregateSelection
}
type DocumentTopicTopicNodeAggregateSelection {
  createdBy: StringAggregateSelectionNonNullable!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type DocumentUserCreatedByAggregationSelection {
  count: Int!
  node: DocumentUserCreatedByNodeAggregateSelection
}
type DocumentUserCreatedByNodeAggregateSelection {
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
  password: StringAggregateSelectionNonNullable!
  email: StringAggregateSelectionNonNullable!
}
type IDAggregateSelectionNonNullable {
  shortest: ID!
  longest: ID!
}
type Org {
  id: ID!
  name: String!
  emailEndings: [String!]!
}
type OrgAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type OrgEdge {
  cursor: String!
  node: Org!
}
type OrgsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [OrgEdge!]!
}
"Pagination information (Relay)"
type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}
type StringAggregateSelectionNonNullable {
  shortest: String!
  longest: String!
}
type TokenSet {
  access_token: String!
  refresh_token: String!
  access_token_exp: String!
  refresh_token_exp: String!
}
type TokenSetAggregateSelection {
  count: Int!
  access_token: StringAggregateSelectionNonNullable!
  refresh_token: StringAggregateSelectionNonNullable!
  access_token_exp: StringAggregateSelectionNonNullable!
  refresh_token_exp: StringAggregateSelectionNonNullable!
}
type TokenSetEdge {
  cursor: String!
  node: TokenSet!
}
type TokenSetsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TokenSetEdge!]!
}
type Topic {
  createdBy: String!
  id: ID!
  name: String!
  category(where: CategoryWhere, options: CategoryOptions, directed: Boolean = true): Category!
  categoryAggregate(where: CategoryWhere, directed: Boolean = true): TopicCategoryCategoryAggregationSelection
  documents(where: DocumentWhere, options: DocumentOptions, directed: Boolean = true): [Document!]!
  documentsAggregate(where: DocumentWhere, directed: Boolean = true): TopicDocumentDocumentsAggregationSelection
  categoryConnection(where: TopicCategoryConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [TopicCategoryConnectionSort!]): TopicCategoryConnection!
  documentsConnection(where: TopicDocumentsConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [TopicDocumentsConnectionSort!]): TopicDocumentsConnection!
}
type TopicAggregateSelection {
  count: Int!
  createdBy: StringAggregateSelectionNonNullable!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type TopicCategoryCategoryAggregationSelection {
  count: Int!
  node: TopicCategoryCategoryNodeAggregateSelection
}
type TopicCategoryCategoryNodeAggregateSelection {
  createdBy: StringAggregateSelectionNonNullable!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type TopicCategoryConnection {
  edges: [TopicCategoryRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type TopicCategoryRelationship {
  cursor: String!
  node: Category!
}
type TopicDocumentDocumentsAggregationSelection {
  count: Int!
  node: TopicDocumentDocumentsNodeAggregateSelection
}
type TopicDocumentDocumentsNodeAggregateSelection {
  id: IDAggregateSelectionNonNullable!
  title: StringAggregateSelectionNonNullable!
  text: StringAggregateSelectionNonNullable!
  url: StringAggregateSelectionNonNullable!
  createdOn: DateTimeAggregateSelectionNonNullable!
  updatedOn: DateTimeAggregateSelectionNonNullable!
}
type TopicDocumentsConnection {
  edges: [TopicDocumentsRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type TopicDocumentsRelationship {
  cursor: String!
  node: Document!
}
type TopicEdge {
  cursor: String!
  node: Topic!
}
type TopicsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [TopicEdge!]!
}
type UpdateCategoriesMutationResponse {
  info: UpdateInfo!
  categories: [Category!]!
}
type UpdateDocumentsMutationResponse {
  info: UpdateInfo!
  documents: [Document!]!
}
type UpdateInfo {
  bookmark: String
  nodesCreated: Int!
  nodesDeleted: Int!
  relationshipsCreated: Int!
  relationshipsDeleted: Int!
}
type UpdateOrgsMutationResponse {
  info: UpdateInfo!
  orgs: [Org!]!
}
type UpdateTokenSetsMutationResponse {
  info: UpdateInfo!
  tokenSets: [TokenSet!]!
}
type UpdateTopicsMutationResponse {
  info: UpdateInfo!
  topics: [Topic!]!
}
type UpdateUserLoginsMutationResponse {
  info: UpdateInfo!
  userLogins: [UserLogin!]!
}
type UpdateUsersMutationResponse {
  info: UpdateInfo!
  users: [User!]!
}
type User {
  id: ID!
  name: String!
  password: String!
  email: String!
  roles: [String!]!
  createdDocuments(where: DocumentWhere, options: DocumentOptions, directed: Boolean = true): [Document!]!
  createdDocumentsAggregate(where: DocumentWhere, directed: Boolean = true): UserDocumentCreatedDocumentsAggregationSelection
  createdDocumentsConnection(where: UserCreatedDocumentsConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [UserCreatedDocumentsConnectionSort!]): UserCreatedDocumentsConnection!
}
type UserAggregateSelection {
  count: Int!
  id: IDAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
  password: StringAggregateSelectionNonNullable!
  email: StringAggregateSelectionNonNullable!
}
type UserCreatedDocumentsConnection {
  edges: [UserCreatedDocumentsRelationship!]!
  totalCount: Int!
  pageInfo: PageInfo!
}
type UserCreatedDocumentsRelationship {
  cursor: String!
  node: Document!
}
type UserDocumentCreatedDocumentsAggregationSelection {
  count: Int!
  node: UserDocumentCreatedDocumentsNodeAggregateSelection
}
type UserDocumentCreatedDocumentsNodeAggregateSelection {
  id: IDAggregateSelectionNonNullable!
  title: StringAggregateSelectionNonNullable!
  text: StringAggregateSelectionNonNullable!
  url: StringAggregateSelectionNonNullable!
  createdOn: DateTimeAggregateSelectionNonNullable!
  updatedOn: DateTimeAggregateSelectionNonNullable!
}
type UserEdge {
  cursor: String!
  node: User!
}
type UserLogin {
  id: String!
  email: String!
  roles: [String!]!
  name: String!
  tokenSet: TokenSet!
}
type UserLoginAggregateSelection {
  count: Int!
  id: StringAggregateSelectionNonNullable!
  email: StringAggregateSelectionNonNullable!
  name: StringAggregateSelectionNonNullable!
}
type UserLoginEdge {
  cursor: String!
  node: UserLogin!
}
type UserLoginsConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserLoginEdge!]!
}
type UsersConnection {
  totalCount: Int!
  pageInfo: PageInfo!
  edges: [UserEdge!]!
}
enum SortDirection {
  "Sort by field values in ascending order."
  ASC
  "Sort by field values in descending order."
  DESC
}
input CategoryConnectInput {
  topics: [CategoryTopicsConnectFieldInput!]
}
input CategoryConnectOrCreateInput {
  topics: [CategoryTopicsConnectOrCreateFieldInput!]
}
input CategoryConnectOrCreateWhere {
  node: CategoryUniqueWhere!
}
input CategoryConnectWhere {
  node: CategoryWhere!
}
input CategoryCreateInput {
  createdBy: String!
  name: String!
  topics: CategoryTopicsFieldInput
}
input CategoryDeleteInput {
  topics: [CategoryTopicsDeleteFieldInput!]
}
input CategoryDisconnectInput {
  topics: [CategoryTopicsDisconnectFieldInput!]
}
input CategoryOnCreateInput {
  createdBy: String!
  name: String!
}
input CategoryOptions {
  "Specify one or more CategorySort objects to sort Categories by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [CategorySort!]
  limit: Int
  offset: Int
}
input CategoryRelationInput {
  topics: [CategoryTopicsCreateFieldInput!]
}
"Fields to sort Categories by. The order in which sorts are applied is not guaranteed when specifying many fields in one CategorySort object."
input CategorySort {
  createdBy: SortDirection
  id: SortDirection
  name: SortDirection
}
input CategoryTopicsAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [CategoryTopicsAggregateInput!]
  OR: [CategoryTopicsAggregateInput!]
  node: CategoryTopicsNodeAggregationWhereInput
}
input CategoryTopicsConnectFieldInput {
  where: TopicConnectWhere
  connect: [TopicConnectInput!]
}
input CategoryTopicsConnectionSort {
  node: TopicSort
}
input CategoryTopicsConnectionWhere {
  AND: [CategoryTopicsConnectionWhere!]
  OR: [CategoryTopicsConnectionWhere!]
  node: TopicWhere
  node_NOT: TopicWhere
}
input CategoryTopicsConnectOrCreateFieldInput {
  where: TopicConnectOrCreateWhere!
  onCreate: CategoryTopicsConnectOrCreateFieldInputOnCreate!
}
input CategoryTopicsConnectOrCreateFieldInputOnCreate {
  node: TopicOnCreateInput!
}
input CategoryTopicsCreateFieldInput {
  node: TopicCreateInput!
}
input CategoryTopicsDeleteFieldInput {
  where: CategoryTopicsConnectionWhere
  delete: TopicDeleteInput
}
input CategoryTopicsDisconnectFieldInput {
  where: CategoryTopicsConnectionWhere
  disconnect: TopicDisconnectInput
}
input CategoryTopicsFieldInput {
  create: [CategoryTopicsCreateFieldInput!]
  connect: [CategoryTopicsConnectFieldInput!]
  connectOrCreate: [CategoryTopicsConnectOrCreateFieldInput!]
}
input CategoryTopicsNodeAggregationWhereInput {
  AND: [CategoryTopicsNodeAggregationWhereInput!]
  OR: [CategoryTopicsNodeAggregationWhereInput!]
  id_EQUAL: ID
  createdBy_EQUAL: String
  createdBy_AVERAGE_EQUAL: Float
  createdBy_LONGEST_EQUAL: Int
  createdBy_SHORTEST_EQUAL: Int
  createdBy_GT: Int
  createdBy_AVERAGE_GT: Float
  createdBy_LONGEST_GT: Int
  createdBy_SHORTEST_GT: Int
  createdBy_GTE: Int
  createdBy_AVERAGE_GTE: Float
  createdBy_LONGEST_GTE: Int
  createdBy_SHORTEST_GTE: Int
  createdBy_LT: Int
  createdBy_AVERAGE_LT: Float
  createdBy_LONGEST_LT: Int
  createdBy_SHORTEST_LT: Int
  createdBy_LTE: Int
  createdBy_AVERAGE_LTE: Float
  createdBy_LONGEST_LTE: Int
  createdBy_SHORTEST_LTE: Int
  name_EQUAL: String
  name_AVERAGE_EQUAL: Float
  name_LONGEST_EQUAL: Int
  name_SHORTEST_EQUAL: Int
  name_GT: Int
  name_AVERAGE_GT: Float
  name_LONGEST_GT: Int
  name_SHORTEST_GT: Int
  name_GTE: Int
  name_AVERAGE_GTE: Float
  name_LONGEST_GTE: Int
  name_SHORTEST_GTE: Int
  name_LT: Int
  name_AVERAGE_LT: Float
  name_LONGEST_LT: Int
  name_SHORTEST_LT: Int
  name_LTE: Int
  name_AVERAGE_LTE: Float
  name_LONGEST_LTE: Int
  name_SHORTEST_LTE: Int
}
input CategoryTopicsUpdateConnectionInput {
  node: TopicUpdateInput
}
input CategoryTopicsUpdateFieldInput {
  where: CategoryTopicsConnectionWhere
  update: CategoryTopicsUpdateConnectionInput
  connect: [CategoryTopicsConnectFieldInput!]
  disconnect: [CategoryTopicsDisconnectFieldInput!]
  create: [CategoryTopicsCreateFieldInput!]
  delete: [CategoryTopicsDeleteFieldInput!]
  connectOrCreate: [CategoryTopicsConnectOrCreateFieldInput!]
}
input CategoryUniqueWhere {
  id: ID
}
input CategoryUpdateInput {
  createdBy: String
  name: String
  topics: [CategoryTopicsUpdateFieldInput!]
}
input CategoryWhere {
  OR: [CategoryWhere!]
  AND: [CategoryWhere!]
  createdBy: String
  createdBy_NOT: String
  createdBy_IN: [String!]
  createdBy_NOT_IN: [String!]
  createdBy_CONTAINS: String
  createdBy_NOT_CONTAINS: String
  createdBy_STARTS_WITH: String
  createdBy_NOT_STARTS_WITH: String
  createdBy_ENDS_WITH: String
  createdBy_NOT_ENDS_WITH: String
  id: ID
  id_NOT: ID
  id_IN: [ID!]
  id_NOT_IN: [ID!]
  id_CONTAINS: ID
  id_NOT_CONTAINS: ID
  id_STARTS_WITH: ID
  id_NOT_STARTS_WITH: ID
  id_ENDS_WITH: ID
  id_NOT_ENDS_WITH: ID
  name: String
  name_NOT: String
  name_IN: [String!]
  name_NOT_IN: [String!]
  name_CONTAINS: String
  name_NOT_CONTAINS: String
  name_STARTS_WITH: String
  name_NOT_STARTS_WITH: String
  name_ENDS_WITH: String
  name_NOT_ENDS_WITH: String
  topicsAggregate: CategoryTopicsAggregateInput
  "Return Categories where all of the related Topics match this filter"
  topics_ALL: TopicWhere
  "Return Categories where none of the related Topics match this filter"
  topics_NONE: TopicWhere
  "Return Categories where one of the related Topics match this filter"
  topics_SINGLE: TopicWhere
  "Return Categories where some of the related Topics match this filter"
  topics_SOME: TopicWhere
  topicsConnection_ALL: CategoryTopicsConnectionWhere
  topicsConnection_NONE: CategoryTopicsConnectionWhere
  topicsConnection_SINGLE: CategoryTopicsConnectionWhere
  topicsConnection_SOME: CategoryTopicsConnectionWhere
}
input DocumentConnectInput {
  topic: DocumentTopicConnectFieldInput
  createdBy: DocumentCreatedByConnectFieldInput
}
input DocumentConnectOrCreateInput {
  topic: DocumentTopicConnectOrCreateFieldInput
  createdBy: DocumentCreatedByConnectOrCreateFieldInput
}
input DocumentConnectOrCreateWhere {
  node: DocumentUniqueWhere!
}
input DocumentConnectWhere {
  node: DocumentWhere!
}
input DocumentCreatedByAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [DocumentCreatedByAggregateInput!]
  OR: [DocumentCreatedByAggregateInput!]
  node: DocumentCreatedByNodeAggregationWhereInput
}
input DocumentCreatedByConnectFieldInput {
  where: UserConnectWhere
  connect: UserConnectInput
}
input DocumentCreatedByConnectionSort {
  node: UserSort
}
input DocumentCreatedByConnectionWhere {
  AND: [DocumentCreatedByConnectionWhere!]
  OR: [DocumentCreatedByConnectionWhere!]
  node: UserWhere
  node_NOT: UserWhere
}
input DocumentCreatedByConnectOrCreateFieldInput {
  where: UserConnectOrCreateWhere!
  onCreate: DocumentCreatedByConnectOrCreateFieldInputOnCreate!
}
input DocumentCreatedByConnectOrCreateFieldInputOnCreate {
  node: UserOnCreateInput!
}
input DocumentCreatedByCreateFieldInput {
  node: UserCreateInput!
}
input DocumentCreatedByDeleteFieldInput {
  where: DocumentCreatedByConnectionWhere
  delete: UserDeleteInput
}
input DocumentCreatedByDisconnectFieldInput {
  where: DocumentCreatedByConnectionWhere
  disconnect: UserDisconnectInput
}
input DocumentCreatedByFieldInput {
  create: DocumentCreatedByCreateFieldInput
  connect: DocumentCreatedByConnectFieldInput
  connectOrCreate: DocumentCreatedByConnectOrCreateFieldInput
}
input DocumentCreatedByNodeAggregationWhereInput {
  AND: [DocumentCreatedByNodeAggregationWhereInput!]
  OR: [DocumentCreatedByNodeAggregationWhereInput!]
  id_EQUAL: ID
  name_EQUAL: String
  name_AVERAGE_EQUAL: Float
  name_LONGEST_EQUAL: Int
  name_SHORTEST_EQUAL: Int
  name_GT: Int
  name_AVERAGE_GT: Float
  name_LONGEST_GT: Int
  name_SHORTEST_GT: Int
  name_GTE: Int
  name_AVERAGE_GTE: Float
  name_LONGEST_GTE: Int
  name_SHORTEST_GTE: Int
  name_LT: Int
  name_AVERAGE_LT: Float
  name_LONGEST_LT: Int
  name_SHORTEST_LT: Int
  name_LTE: Int
  name_AVERAGE_LTE: Float
  name_LONGEST_LTE: Int
  name_SHORTEST_LTE: Int
  password_EQUAL: String
  password_AVERAGE_EQUAL: Float
  password_LONGEST_EQUAL: Int
  password_SHORTEST_EQUAL: Int
  password_GT: Int
  password_AVERAGE_GT: Float
  password_LONGEST_GT: Int
  password_SHORTEST_GT: Int
  password_GTE: Int
  password_AVERAGE_GTE: Float
  password_LONGEST_GTE: Int
  password_SHORTEST_GTE: Int
  password_LT: Int
  password_AVERAGE_LT: Float
  password_LONGEST_LT: Int
  password_SHORTEST_LT: Int
  password_LTE: Int
  password_AVERAGE_LTE: Float
  password_LONGEST_LTE: Int
  password_SHORTEST_LTE: Int
  email_EQUAL: String
  email_AVERAGE_EQUAL: Float
  email_LONGEST_EQUAL: Int
  email_SHORTEST_EQUAL: Int
  email_GT: Int
  email_AVERAGE_GT: Float
  email_LONGEST_GT: Int
  email_SHORTEST_GT: Int
  email_GTE: Int
  email_AVERAGE_GTE: Float
  email_LONGEST_GTE: Int
  email_SHORTEST_GTE: Int
  email_LT: Int
  email_AVERAGE_LT: Float
  email_LONGEST_LT: Int
  email_SHORTEST_LT: Int
  email_LTE: Int
  email_AVERAGE_LTE: Float
  email_LONGEST_LTE: Int
  email_SHORTEST_LTE: Int
}
input DocumentCreatedByUpdateConnectionInput {
  node: UserUpdateInput
}
input DocumentCreatedByUpdateFieldInput {
  where: DocumentCreatedByConnectionWhere
  update: DocumentCreatedByUpdateConnectionInput
  connect: DocumentCreatedByConnectFieldInput
  disconnect: DocumentCreatedByDisconnectFieldInput
  create: DocumentCreatedByCreateFieldInput
  delete: DocumentCreatedByDeleteFieldInput
  connectOrCreate: DocumentCreatedByConnectOrCreateFieldInput
}
input DocumentCreateInput {
  title: String!
  text: String!
  url: String!
  topic: [String!]!
}
input DocumentDeleteInput {
  topic: DocumentTopicDeleteFieldInput
  createdBy: DocumentCreatedByDeleteFieldInput
}
input DocumentDisconnectInput {
  topic: DocumentTopicDisconnectFieldInput
  createdBy: DocumentCreatedByDisconnectFieldInput
}
input DocumentOnCreateInput {
  title: String!
  text: String!
  url: String!
  verified: Boolean!
  deleted: Boolean!
  createdOn: DateTime!
  updatedOn: DateTime!
}
input DocumentOptions {
  "Specify one or more DocumentSort objects to sort Documents by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [DocumentSort!]
  limit: Int
  offset: Int
}
input DocumentRelationInput {
  topic: DocumentTopicCreateFieldInput
  createdBy: DocumentCreatedByCreateFieldInput
}
"Fields to sort Documents by. The order in which sorts are applied is not guaranteed when specifying many fields in one DocumentSort object."
input DocumentSort {
  id: SortDirection
  title: SortDirection
  text: SortDirection
  url: SortDirection
  verified: SortDirection
  deleted: SortDirection
  createdOn: SortDirection
  updatedOn: SortDirection
}
input DocumentTopicAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [DocumentTopicAggregateInput!]
  OR: [DocumentTopicAggregateInput!]
  node: DocumentTopicNodeAggregationWhereInput
}
input DocumentTopicConnectFieldInput {
  where: TopicConnectWhere
  connect: TopicConnectInput
}
input DocumentTopicConnectionSort {
  node: TopicSort
}
input DocumentTopicConnectionWhere {
  AND: [DocumentTopicConnectionWhere!]
  OR: [DocumentTopicConnectionWhere!]
  node: TopicWhere
  node_NOT: TopicWhere
}
input DocumentTopicConnectOrCreateFieldInput {
  where: TopicConnectOrCreateWhere!
  onCreate: DocumentTopicConnectOrCreateFieldInputOnCreate!
}
input DocumentTopicConnectOrCreateFieldInputOnCreate {
  node: TopicOnCreateInput!
}
input DocumentTopicCreateFieldInput {
  node: TopicCreateInput!
}
input DocumentTopicDeleteFieldInput {
  where: DocumentTopicConnectionWhere
  delete: TopicDeleteInput
}
input DocumentTopicDisconnectFieldInput {
  where: DocumentTopicConnectionWhere
  disconnect: TopicDisconnectInput
}
input DocumentTopicFieldInput {
  create: DocumentTopicCreateFieldInput
  connect: DocumentTopicConnectFieldInput
  connectOrCreate: DocumentTopicConnectOrCreateFieldInput
}
input DocumentTopicNodeAggregationWhereInput {
  AND: [DocumentTopicNodeAggregationWhereInput!]
  OR: [DocumentTopicNodeAggregationWhereInput!]
  id_EQUAL: ID
  createdBy_EQUAL: String
  createdBy_AVERAGE_EQUAL: Float
  createdBy_LONGEST_EQUAL: Int
  createdBy_SHORTEST_EQUAL: Int
  createdBy_GT: Int
  createdBy_AVERAGE_GT: Float
  createdBy_LONGEST_GT: Int
  createdBy_SHORTEST_GT: Int
  createdBy_GTE: Int
  createdBy_AVERAGE_GTE: Float
  createdBy_LONGEST_GTE: Int
  createdBy_SHORTEST_GTE: Int
  createdBy_LT: Int
  createdBy_AVERAGE_LT: Float
  createdBy_LONGEST_LT: Int
  createdBy_SHORTEST_LT: Int
  createdBy_LTE: Int
  createdBy_AVERAGE_LTE: Float
  createdBy_LONGEST_LTE: Int
  createdBy_SHORTEST_LTE: Int
  name_EQUAL: String
  name_AVERAGE_EQUAL: Float
  name_LONGEST_EQUAL: Int
  name_SHORTEST_EQUAL: Int
  name_GT: Int
  name_AVERAGE_GT: Float
  name_LONGEST_GT: Int
  name_SHORTEST_GT: Int
  name_GTE: Int
  name_AVERAGE_GTE: Float
  name_LONGEST_GTE: Int
  name_SHORTEST_GTE: Int
  name_LT: Int
  name_AVERAGE_LT: Float
  name_LONGEST_LT: Int
  name_SHORTEST_LT: Int
  name_LTE: Int
  name_AVERAGE_LTE: Float
  name_LONGEST_LTE: Int
  name_SHORTEST_LTE: Int
}
input DocumentTopicUpdateConnectionInput {
  node: TopicUpdateInput
}
input DocumentTopicUpdateFieldInput {
  where: DocumentTopicConnectionWhere
  update: DocumentTopicUpdateConnectionInput
  connect: DocumentTopicConnectFieldInput
  disconnect: DocumentTopicDisconnectFieldInput
  create: DocumentTopicCreateFieldInput
  delete: DocumentTopicDeleteFieldInput
  connectOrCreate: DocumentTopicConnectOrCreateFieldInput
}
input DocumentUniqueWhere {
  id: ID
}
input DocumentUpdateInput {
  title: String!
  text: String!
  url: String!
  id: String
}
input DocumentWhere {
  OR: [DocumentWhere!]
  AND: [DocumentWhere!]
  id: ID
  id_NOT: ID
  id_IN: [ID!]
  id_NOT_IN: [ID!]
  id_CONTAINS: ID
  id_NOT_CONTAINS: ID
  id_STARTS_WITH: ID
  id_NOT_STARTS_WITH: ID
  id_ENDS_WITH: ID
  id_NOT_ENDS_WITH: ID
  title: String
  title_NOT: String
  title_IN: [String!]
  title_NOT_IN: [String!]
  title_CONTAINS: String
  title_NOT_CONTAINS: String
  title_STARTS_WITH: String
  title_NOT_STARTS_WITH: String
  title_ENDS_WITH: String
  title_NOT_ENDS_WITH: String
  text: String
  text_NOT: String
  text_IN: [String!]
  text_NOT_IN: [String!]
  text_CONTAINS: String
  text_NOT_CONTAINS: String
  text_STARTS_WITH: String
  text_NOT_STARTS_WITH: String
  text_ENDS_WITH: String
  text_NOT_ENDS_WITH: String
  url: String
  url_NOT: String
  url_IN: [String!]
  url_NOT_IN: [String!]
  url_CONTAINS: String
  url_NOT_CONTAINS: String
  url_STARTS_WITH: String
  url_NOT_STARTS_WITH: String
  url_ENDS_WITH: String
  url_NOT_ENDS_WITH: String
  verified: Boolean
  verified_NOT: Boolean
  deleted: Boolean
  deleted_NOT: Boolean
  createdOn: DateTime
  createdOn_NOT: DateTime
  createdOn_IN: [DateTime!]
  createdOn_NOT_IN: [DateTime!]
  createdOn_LT: DateTime
  createdOn_LTE: DateTime
  createdOn_GT: DateTime
  createdOn_GTE: DateTime
  updatedOn: DateTime
  updatedOn_NOT: DateTime
  updatedOn_IN: [DateTime!]
  updatedOn_NOT_IN: [DateTime!]
  updatedOn_LT: DateTime
  updatedOn_LTE: DateTime
  updatedOn_GT: DateTime
  updatedOn_GTE: DateTime
  topic: TopicWhere
  topic_NOT: TopicWhere
  topicAggregate: DocumentTopicAggregateInput
  createdBy: UserWhere
  createdBy_NOT: UserWhere
  createdByAggregate: DocumentCreatedByAggregateInput
  topicConnection: DocumentTopicConnectionWhere
  topicConnection_NOT: DocumentTopicConnectionWhere
  createdByConnection: DocumentCreatedByConnectionWhere
  createdByConnection_NOT: DocumentCreatedByConnectionWhere
}
input OrgCreateInput {
  name: String!
  emailEndings: [String!]!
}
input OrgOptions {
  "Specify one or more OrgSort objects to sort Orgs by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [OrgSort!]
  limit: Int
  offset: Int
}
"Fields to sort Orgs by. The order in which sorts are applied is not guaranteed when specifying many fields in one OrgSort object."
input OrgSort {
  id: SortDirection
  name: SortDirection
}
input OrgUpdateInput {
  name: String
  emailEndings: [String!]
}
input OrgWhere {
  OR: [OrgWhere!]
  AND: [OrgWhere!]
  id: ID
  id_NOT: ID
  id_IN: [ID!]
  id_NOT_IN: [ID!]
  id_CONTAINS: ID
  id_NOT_CONTAINS: ID
  id_STARTS_WITH: ID
  id_NOT_STARTS_WITH: ID
  id_ENDS_WITH: ID
  id_NOT_ENDS_WITH: ID
  name: String
  name_NOT: String
  name_IN: [String!]
  name_NOT_IN: [String!]
  name_CONTAINS: String
  name_NOT_CONTAINS: String
  name_STARTS_WITH: String
  name_NOT_STARTS_WITH: String
  name_ENDS_WITH: String
  name_NOT_ENDS_WITH: String
  emailEndings: [String!]
  emailEndings_NOT: [String!]
  emailEndings_INCLUDES: String
  emailEndings_NOT_INCLUDES: String
}
input TokenSetCreateInput {
  access_token: String!
  refresh_token: String!
  access_token_exp: String!
  refresh_token_exp: String!
}
input TokenSetOptions {
  "Specify one or more TokenSetSort objects to sort TokenSets by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [TokenSetSort!]
  limit: Int
  offset: Int
}
"Fields to sort TokenSets by. The order in which sorts are applied is not guaranteed when specifying many fields in one TokenSetSort object."
input TokenSetSort {
  access_token: SortDirection
  refresh_token: SortDirection
  access_token_exp: SortDirection
  refresh_token_exp: SortDirection
}
input TokenSetUpdateInput {
  access_token: String
  refresh_token: String
  access_token_exp: String
  refresh_token_exp: String
}
input TokenSetWhere {
  OR: [TokenSetWhere!]
  AND: [TokenSetWhere!]
  access_token: String
  access_token_NOT: String
  access_token_IN: [String!]
  access_token_NOT_IN: [String!]
  access_token_CONTAINS: String
  access_token_NOT_CONTAINS: String
  access_token_STARTS_WITH: String
  access_token_NOT_STARTS_WITH: String
  access_token_ENDS_WITH: String
  access_token_NOT_ENDS_WITH: String
  refresh_token: String
  refresh_token_NOT: String
  refresh_token_IN: [String!]
  refresh_token_NOT_IN: [String!]
  refresh_token_CONTAINS: String
  refresh_token_NOT_CONTAINS: String
  refresh_token_STARTS_WITH: String
  refresh_token_NOT_STARTS_WITH: String
  refresh_token_ENDS_WITH: String
  refresh_token_NOT_ENDS_WITH: String
  access_token_exp: String
  access_token_exp_NOT: String
  access_token_exp_IN: [String!]
  access_token_exp_NOT_IN: [String!]
  access_token_exp_CONTAINS: String
  access_token_exp_NOT_CONTAINS: String
  access_token_exp_STARTS_WITH: String
  access_token_exp_NOT_STARTS_WITH: String
  access_token_exp_ENDS_WITH: String
  access_token_exp_NOT_ENDS_WITH: String
  refresh_token_exp: String
  refresh_token_exp_NOT: String
  refresh_token_exp_IN: [String!]
  refresh_token_exp_NOT_IN: [String!]
  refresh_token_exp_CONTAINS: String
  refresh_token_exp_NOT_CONTAINS: String
  refresh_token_exp_STARTS_WITH: String
  refresh_token_exp_NOT_STARTS_WITH: String
  refresh_token_exp_ENDS_WITH: String
  refresh_token_exp_NOT_ENDS_WITH: String
}
input TopicCategoryAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [TopicCategoryAggregateInput!]
  OR: [TopicCategoryAggregateInput!]
  node: TopicCategoryNodeAggregationWhereInput
}
input TopicCategoryConnectFieldInput {
  where: CategoryConnectWhere
  connect: CategoryConnectInput
}
input TopicCategoryConnectionSort {
  node: CategorySort
}
input TopicCategoryConnectionWhere {
  AND: [TopicCategoryConnectionWhere!]
  OR: [TopicCategoryConnectionWhere!]
  node: CategoryWhere
  node_NOT: CategoryWhere
}
input TopicCategoryConnectOrCreateFieldInput {
  where: CategoryConnectOrCreateWhere!
  onCreate: TopicCategoryConnectOrCreateFieldInputOnCreate!
}
input TopicCategoryConnectOrCreateFieldInputOnCreate {
  node: CategoryOnCreateInput!
}
input TopicCategoryCreateFieldInput {
  node: CategoryCreateInput!
}
input TopicCategoryDeleteFieldInput {
  where: TopicCategoryConnectionWhere
  delete: CategoryDeleteInput
}
input TopicCategoryDisconnectFieldInput {
  where: TopicCategoryConnectionWhere
  disconnect: CategoryDisconnectInput
}
input TopicCategoryFieldInput {
  create: TopicCategoryCreateFieldInput
  connect: TopicCategoryConnectFieldInput
  connectOrCreate: TopicCategoryConnectOrCreateFieldInput
}
input TopicCategoryNodeAggregationWhereInput {
  AND: [TopicCategoryNodeAggregationWhereInput!]
  OR: [TopicCategoryNodeAggregationWhereInput!]
  id_EQUAL: ID
  createdBy_EQUAL: String
  createdBy_AVERAGE_EQUAL: Float
  createdBy_LONGEST_EQUAL: Int
  createdBy_SHORTEST_EQUAL: Int
  createdBy_GT: Int
  createdBy_AVERAGE_GT: Float
  createdBy_LONGEST_GT: Int
  createdBy_SHORTEST_GT: Int
  createdBy_GTE: Int
  createdBy_AVERAGE_GTE: Float
  createdBy_LONGEST_GTE: Int
  createdBy_SHORTEST_GTE: Int
  createdBy_LT: Int
  createdBy_AVERAGE_LT: Float
  createdBy_LONGEST_LT: Int
  createdBy_SHORTEST_LT: Int
  createdBy_LTE: Int
  createdBy_AVERAGE_LTE: Float
  createdBy_LONGEST_LTE: Int
  createdBy_SHORTEST_LTE: Int
  name_EQUAL: String
  name_AVERAGE_EQUAL: Float
  name_LONGEST_EQUAL: Int
  name_SHORTEST_EQUAL: Int
  name_GT: Int
  name_AVERAGE_GT: Float
  name_LONGEST_GT: Int
  name_SHORTEST_GT: Int
  name_GTE: Int
  name_AVERAGE_GTE: Float
  name_LONGEST_GTE: Int
  name_SHORTEST_GTE: Int
  name_LT: Int
  name_AVERAGE_LT: Float
  name_LONGEST_LT: Int
  name_SHORTEST_LT: Int
  name_LTE: Int
  name_AVERAGE_LTE: Float
  name_LONGEST_LTE: Int
  name_SHORTEST_LTE: Int
}
input TopicCategoryUpdateConnectionInput {
  node: CategoryUpdateInput
}
input TopicCategoryUpdateFieldInput {
  where: TopicCategoryConnectionWhere
  update: TopicCategoryUpdateConnectionInput
  connect: TopicCategoryConnectFieldInput
  disconnect: TopicCategoryDisconnectFieldInput
  create: TopicCategoryCreateFieldInput
  delete: TopicCategoryDeleteFieldInput
  connectOrCreate: TopicCategoryConnectOrCreateFieldInput
}
input TopicConnectInput {
  category: TopicCategoryConnectFieldInput
  documents: [TopicDocumentsConnectFieldInput!]
}
input TopicConnectOrCreateInput {
  category: TopicCategoryConnectOrCreateFieldInput
  documents: [TopicDocumentsConnectOrCreateFieldInput!]
}
input TopicConnectOrCreateWhere {
  node: TopicUniqueWhere!
}
input TopicConnectWhere {
  node: TopicWhere!
}
input TopicCreateInput {
  createdBy: String!
  name: String!
  category: TopicCategoryFieldInput
  documents: TopicDocumentsFieldInput
}
input TopicDeleteInput {
  category: TopicCategoryDeleteFieldInput
  documents: [TopicDocumentsDeleteFieldInput!]
}
input TopicDisconnectInput {
  category: TopicCategoryDisconnectFieldInput
  documents: [TopicDocumentsDisconnectFieldInput!]
}
input TopicDocumentsAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [TopicDocumentsAggregateInput!]
  OR: [TopicDocumentsAggregateInput!]
  node: TopicDocumentsNodeAggregationWhereInput
}
input TopicDocumentsConnectFieldInput {
  where: DocumentConnectWhere
  connect: [DocumentConnectInput!]
}
input TopicDocumentsConnectionSort {
  node: DocumentSort
}
input TopicDocumentsConnectionWhere {
  AND: [TopicDocumentsConnectionWhere!]
  OR: [TopicDocumentsConnectionWhere!]
  node: DocumentWhere
  node_NOT: DocumentWhere
}
input TopicDocumentsConnectOrCreateFieldInput {
  where: DocumentConnectOrCreateWhere!
  onCreate: TopicDocumentsConnectOrCreateFieldInputOnCreate!
}
input TopicDocumentsConnectOrCreateFieldInputOnCreate {
  node: DocumentOnCreateInput!
}
input TopicDocumentsCreateFieldInput {
  node: DocumentCreateInput!
}
input TopicDocumentsDeleteFieldInput {
  where: TopicDocumentsConnectionWhere
  delete: DocumentDeleteInput
}
input TopicDocumentsDisconnectFieldInput {
  where: TopicDocumentsConnectionWhere
  disconnect: DocumentDisconnectInput
}
input TopicDocumentsFieldInput {
  create: [TopicDocumentsCreateFieldInput!]
  connect: [TopicDocumentsConnectFieldInput!]
  connectOrCreate: [TopicDocumentsConnectOrCreateFieldInput!]
}
input TopicDocumentsNodeAggregationWhereInput {
  AND: [TopicDocumentsNodeAggregationWhereInput!]
  OR: [TopicDocumentsNodeAggregationWhereInput!]
  id_EQUAL: ID
  title_EQUAL: String
  title_AVERAGE_EQUAL: Float
  title_LONGEST_EQUAL: Int
  title_SHORTEST_EQUAL: Int
  title_GT: Int
  title_AVERAGE_GT: Float
  title_LONGEST_GT: Int
  title_SHORTEST_GT: Int
  title_GTE: Int
  title_AVERAGE_GTE: Float
  title_LONGEST_GTE: Int
  title_SHORTEST_GTE: Int
  title_LT: Int
  title_AVERAGE_LT: Float
  title_LONGEST_LT: Int
  title_SHORTEST_LT: Int
  title_LTE: Int
  title_AVERAGE_LTE: Float
  title_LONGEST_LTE: Int
  title_SHORTEST_LTE: Int
  text_EQUAL: String
  text_AVERAGE_EQUAL: Float
  text_LONGEST_EQUAL: Int
  text_SHORTEST_EQUAL: Int
  text_GT: Int
  text_AVERAGE_GT: Float
  text_LONGEST_GT: Int
  text_SHORTEST_GT: Int
  text_GTE: Int
  text_AVERAGE_GTE: Float
  text_LONGEST_GTE: Int
  text_SHORTEST_GTE: Int
  text_LT: Int
  text_AVERAGE_LT: Float
  text_LONGEST_LT: Int
  text_SHORTEST_LT: Int
  text_LTE: Int
  text_AVERAGE_LTE: Float
  text_LONGEST_LTE: Int
  text_SHORTEST_LTE: Int
  url_EQUAL: String
  url_AVERAGE_EQUAL: Float
  url_LONGEST_EQUAL: Int
  url_SHORTEST_EQUAL: Int
  url_GT: Int
  url_AVERAGE_GT: Float
  url_LONGEST_GT: Int
  url_SHORTEST_GT: Int
  url_GTE: Int
  url_AVERAGE_GTE: Float
  url_LONGEST_GTE: Int
  url_SHORTEST_GTE: Int
  url_LT: Int
  url_AVERAGE_LT: Float
  url_LONGEST_LT: Int
  url_SHORTEST_LT: Int
  url_LTE: Int
  url_AVERAGE_LTE: Float
  url_LONGEST_LTE: Int
  url_SHORTEST_LTE: Int
  createdOn_EQUAL: DateTime
  createdOn_MIN_EQUAL: DateTime
  createdOn_MAX_EQUAL: DateTime
  createdOn_GT: DateTime
  createdOn_MIN_GT: DateTime
  createdOn_MAX_GT: DateTime
  createdOn_GTE: DateTime
  createdOn_MIN_GTE: DateTime
  createdOn_MAX_GTE: DateTime
  createdOn_LT: DateTime
  createdOn_MIN_LT: DateTime
  createdOn_MAX_LT: DateTime
  createdOn_LTE: DateTime
  createdOn_MIN_LTE: DateTime
  createdOn_MAX_LTE: DateTime
  updatedOn_EQUAL: DateTime
  updatedOn_MIN_EQUAL: DateTime
  updatedOn_MAX_EQUAL: DateTime
  updatedOn_GT: DateTime
  updatedOn_MIN_GT: DateTime
  updatedOn_MAX_GT: DateTime
  updatedOn_GTE: DateTime
  updatedOn_MIN_GTE: DateTime
  updatedOn_MAX_GTE: DateTime
  updatedOn_LT: DateTime
  updatedOn_MIN_LT: DateTime
  updatedOn_MAX_LT: DateTime
  updatedOn_LTE: DateTime
  updatedOn_MIN_LTE: DateTime
  updatedOn_MAX_LTE: DateTime
}
input TopicDocumentsUpdateConnectionInput {
  node: DocumentUpdateInput
}
input TopicDocumentsUpdateFieldInput {
  where: TopicDocumentsConnectionWhere
  update: TopicDocumentsUpdateConnectionInput
  connect: [TopicDocumentsConnectFieldInput!]
  disconnect: [TopicDocumentsDisconnectFieldInput!]
  create: [TopicDocumentsCreateFieldInput!]
  delete: [TopicDocumentsDeleteFieldInput!]
  connectOrCreate: [TopicDocumentsConnectOrCreateFieldInput!]
}
input TopicOnCreateInput {
  createdBy: String!
  name: String!
}
input TopicOptions {
  "Specify one or more TopicSort objects to sort Topics by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [TopicSort!]
  limit: Int
  offset: Int
}
input TopicRelationInput {
  category: TopicCategoryCreateFieldInput
  documents: [TopicDocumentsCreateFieldInput!]
}
"Fields to sort Topics by. The order in which sorts are applied is not guaranteed when specifying many fields in one TopicSort object."
input TopicSort {
  createdBy: SortDirection
  id: SortDirection
  name: SortDirection
}
input TopicUniqueWhere {
  id: ID
}
input TopicUpdateInput {
  createdBy: String
  name: String
  category: TopicCategoryUpdateFieldInput
  documents: [TopicDocumentsUpdateFieldInput!]
}
input TopicWhere {
  OR: [TopicWhere!]
  AND: [TopicWhere!]
  createdBy: String
  createdBy_NOT: String
  createdBy_IN: [String!]
  createdBy_NOT_IN: [String!]
  createdBy_CONTAINS: String
  createdBy_NOT_CONTAINS: String
  createdBy_STARTS_WITH: String
  createdBy_NOT_STARTS_WITH: String
  createdBy_ENDS_WITH: String
  createdBy_NOT_ENDS_WITH: String
  id: ID
  id_NOT: ID
  id_IN: [ID!]
  id_NOT_IN: [ID!]
  id_CONTAINS: ID
  id_NOT_CONTAINS: ID
  id_STARTS_WITH: ID
  id_NOT_STARTS_WITH: ID
  id_ENDS_WITH: ID
  id_NOT_ENDS_WITH: ID
  name: String
  name_NOT: String
  name_IN: [String!]
  name_NOT_IN: [String!]
  name_CONTAINS: String
  name_NOT_CONTAINS: String
  name_STARTS_WITH: String
  name_NOT_STARTS_WITH: String
  name_ENDS_WITH: String
  name_NOT_ENDS_WITH: String
  category: CategoryWhere
  category_NOT: CategoryWhere
  categoryAggregate: TopicCategoryAggregateInput
  documentsAggregate: TopicDocumentsAggregateInput
  "Return Topics where all of the related Documents match this filter"
  documents_ALL: DocumentWhere
  "Return Topics where none of the related Documents match this filter"
  documents_NONE: DocumentWhere
  "Return Topics where one of the related Documents match this filter"
  documents_SINGLE: DocumentWhere
  "Return Topics where some of the related Documents match this filter"
  documents_SOME: DocumentWhere
  categoryConnection: TopicCategoryConnectionWhere
  categoryConnection_NOT: TopicCategoryConnectionWhere
  documentsConnection_ALL: TopicDocumentsConnectionWhere
  documentsConnection_NONE: TopicDocumentsConnectionWhere
  documentsConnection_SINGLE: TopicDocumentsConnectionWhere
  documentsConnection_SOME: TopicDocumentsConnectionWhere
}
input UserConnectInput {
  createdDocuments: [UserCreatedDocumentsConnectFieldInput!]
}
input UserConnectOrCreateInput {
  createdDocuments: [UserCreatedDocumentsConnectOrCreateFieldInput!]
}
input UserConnectOrCreateWhere {
  node: UserUniqueWhere!
}
input UserConnectWhere {
  node: UserWhere!
}
input UserCreatedDocumentsAggregateInput {
  count: Int
  count_LT: Int
  count_LTE: Int
  count_GT: Int
  count_GTE: Int
  AND: [UserCreatedDocumentsAggregateInput!]
  OR: [UserCreatedDocumentsAggregateInput!]
  node: UserCreatedDocumentsNodeAggregationWhereInput
}
input UserCreatedDocumentsConnectFieldInput {
  where: DocumentConnectWhere
  connect: [DocumentConnectInput!]
}
input UserCreatedDocumentsConnectionSort {
  node: DocumentSort
}
input UserCreatedDocumentsConnectionWhere {
  AND: [UserCreatedDocumentsConnectionWhere!]
  OR: [UserCreatedDocumentsConnectionWhere!]
  node: DocumentWhere
  node_NOT: DocumentWhere
}
input UserCreatedDocumentsConnectOrCreateFieldInput {
  where: DocumentConnectOrCreateWhere!
  onCreate: UserCreatedDocumentsConnectOrCreateFieldInputOnCreate!
}
input UserCreatedDocumentsConnectOrCreateFieldInputOnCreate {
  node: DocumentOnCreateInput!
}
input UserCreatedDocumentsCreateFieldInput {
  node: DocumentCreateInput!
}
input UserCreatedDocumentsDeleteFieldInput {
  where: UserCreatedDocumentsConnectionWhere
  delete: DocumentDeleteInput
}
input UserCreatedDocumentsDisconnectFieldInput {
  where: UserCreatedDocumentsConnectionWhere
  disconnect: DocumentDisconnectInput
}
input UserCreatedDocumentsFieldInput {
  create: [UserCreatedDocumentsCreateFieldInput!]
  connect: [UserCreatedDocumentsConnectFieldInput!]
  connectOrCreate: [UserCreatedDocumentsConnectOrCreateFieldInput!]
}
input UserCreatedDocumentsNodeAggregationWhereInput {
  AND: [UserCreatedDocumentsNodeAggregationWhereInput!]
  OR: [UserCreatedDocumentsNodeAggregationWhereInput!]
  id_EQUAL: ID
  title_EQUAL: String
  title_AVERAGE_EQUAL: Float
  title_LONGEST_EQUAL: Int
  title_SHORTEST_EQUAL: Int
  title_GT: Int
  title_AVERAGE_GT: Float
  title_LONGEST_GT: Int
  title_SHORTEST_GT: Int
  title_GTE: Int
  title_AVERAGE_GTE: Float
  title_LONGEST_GTE: Int
  title_SHORTEST_GTE: Int
  title_LT: Int
  title_AVERAGE_LT: Float
  title_LONGEST_LT: Int
  title_SHORTEST_LT: Int
  title_LTE: Int
  title_AVERAGE_LTE: Float
  title_LONGEST_LTE: Int
  title_SHORTEST_LTE: Int
  text_EQUAL: String
  text_AVERAGE_EQUAL: Float
  text_LONGEST_EQUAL: Int
  text_SHORTEST_EQUAL: Int
  text_GT: Int
  text_AVERAGE_GT: Float
  text_LONGEST_GT: Int
  text_SHORTEST_GT: Int
  text_GTE: Int
  text_AVERAGE_GTE: Float
  text_LONGEST_GTE: Int
  text_SHORTEST_GTE: Int
  text_LT: Int
  text_AVERAGE_LT: Float
  text_LONGEST_LT: Int
  text_SHORTEST_LT: Int
  text_LTE: Int
  text_AVERAGE_LTE: Float
  text_LONGEST_LTE: Int
  text_SHORTEST_LTE: Int
  url_EQUAL: String
  url_AVERAGE_EQUAL: Float
  url_LONGEST_EQUAL: Int
  url_SHORTEST_EQUAL: Int
  url_GT: Int
  url_AVERAGE_GT: Float
  url_LONGEST_GT: Int
  url_SHORTEST_GT: Int
  url_GTE: Int
  url_AVERAGE_GTE: Float
  url_LONGEST_GTE: Int
  url_SHORTEST_GTE: Int
  url_LT: Int
  url_AVERAGE_LT: Float
  url_LONGEST_LT: Int
  url_SHORTEST_LT: Int
  url_LTE: Int
  url_AVERAGE_LTE: Float
  url_LONGEST_LTE: Int
  url_SHORTEST_LTE: Int
  createdOn_EQUAL: DateTime
  createdOn_MIN_EQUAL: DateTime
  createdOn_MAX_EQUAL: DateTime
  createdOn_GT: DateTime
  createdOn_MIN_GT: DateTime
  createdOn_MAX_GT: DateTime
  createdOn_GTE: DateTime
  createdOn_MIN_GTE: DateTime
  createdOn_MAX_GTE: DateTime
  createdOn_LT: DateTime
  createdOn_MIN_LT: DateTime
  createdOn_MAX_LT: DateTime
  createdOn_LTE: DateTime
  createdOn_MIN_LTE: DateTime
  createdOn_MAX_LTE: DateTime
  updatedOn_EQUAL: DateTime
  updatedOn_MIN_EQUAL: DateTime
  updatedOn_MAX_EQUAL: DateTime
  updatedOn_GT: DateTime
  updatedOn_MIN_GT: DateTime
  updatedOn_MAX_GT: DateTime
  updatedOn_GTE: DateTime
  updatedOn_MIN_GTE: DateTime
  updatedOn_MAX_GTE: DateTime
  updatedOn_LT: DateTime
  updatedOn_MIN_LT: DateTime
  updatedOn_MAX_LT: DateTime
  updatedOn_LTE: DateTime
  updatedOn_MIN_LTE: DateTime
  updatedOn_MAX_LTE: DateTime
}
input UserCreatedDocumentsUpdateConnectionInput {
  node: DocumentUpdateInput
}
input UserCreatedDocumentsUpdateFieldInput {
  where: UserCreatedDocumentsConnectionWhere
  update: UserCreatedDocumentsUpdateConnectionInput
  connect: [UserCreatedDocumentsConnectFieldInput!]
  disconnect: [UserCreatedDocumentsDisconnectFieldInput!]
  create: [UserCreatedDocumentsCreateFieldInput!]
  delete: [UserCreatedDocumentsDeleteFieldInput!]
  connectOrCreate: [UserCreatedDocumentsConnectOrCreateFieldInput!]
}
input UserCreateInput {
  name: String!
  password: String!
  email: String!
  roles: [String!]!
  createdDocuments: UserCreatedDocumentsFieldInput
}
input UserDeleteInput {
  createdDocuments: [UserCreatedDocumentsDeleteFieldInput!]
}
input UserDisconnectInput {
  createdDocuments: [UserCreatedDocumentsDisconnectFieldInput!]
}
input UserLoginCreateInput {
  id: String!
  email: String!
  roles: [String!]!
  name: String!
}
input UserLoginOptions {
  "Specify one or more UserLoginSort objects to sort UserLogins by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [UserLoginSort!]
  limit: Int
  offset: Int
}
"Fields to sort UserLogins by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserLoginSort object."
input UserLoginSort {
  id: SortDirection
  email: SortDirection
  name: SortDirection
}
input UserLoginUpdateInput {
  id: String
  email: String
  roles: [String!]
  name: String
}
input UserLoginWhere {
  OR: [UserLoginWhere!]
  AND: [UserLoginWhere!]
  id: String
  id_NOT: String
  id_IN: [String!]
  id_NOT_IN: [String!]
  id_CONTAINS: String
  id_NOT_CONTAINS: String
  id_STARTS_WITH: String
  id_NOT_STARTS_WITH: String
  id_ENDS_WITH: String
  id_NOT_ENDS_WITH: String
  email: String
  email_NOT: String
  email_IN: [String!]
  email_NOT_IN: [String!]
  email_CONTAINS: String
  email_NOT_CONTAINS: String
  email_STARTS_WITH: String
  email_NOT_STARTS_WITH: String
  email_ENDS_WITH: String
  email_NOT_ENDS_WITH: String
  roles: [String!]
  roles_NOT: [String!]
  roles_INCLUDES: String
  roles_NOT_INCLUDES: String
  name: String
  name_NOT: String
  name_IN: [String!]
  name_NOT_IN: [String!]
  name_CONTAINS: String
  name_NOT_CONTAINS: String
  name_STARTS_WITH: String
  name_NOT_STARTS_WITH: String
  name_ENDS_WITH: String
  name_NOT_ENDS_WITH: String
}
input UserOnCreateInput {
  name: String!
  password: String!
  email: String!
  roles: [String!]!
}
input UserOptions {
  "Specify one or more UserSort objects to sort Users by. The sorts will be applied in the order in which they are arranged in the array."
  sort: [UserSort!]
  limit: Int
  offset: Int
}
input UserRelationInput {
  createdDocuments: [UserCreatedDocumentsCreateFieldInput!]
}
"Fields to sort Users by. The order in which sorts are applied is not guaranteed when specifying many fields in one UserSort object."
input UserSort {
  id: SortDirection
  name: SortDirection
  password: SortDirection
  email: SortDirection
}
input UserUniqueWhere {
  id: ID
  email: String
}
input UserUpdateInput {
  name: String
  password: String
  email: String
  roles: [String!]
  createdDocuments: [UserCreatedDocumentsUpdateFieldInput!]
}
input UserWhere {
  OR: [UserWhere!]
  AND: [UserWhere!]
  id: ID
  id_NOT: ID
  id_IN: [ID!]
  id_NOT_IN: [ID!]
  id_CONTAINS: ID
  id_NOT_CONTAINS: ID
  id_STARTS_WITH: ID
  id_NOT_STARTS_WITH: ID
  id_ENDS_WITH: ID
  id_NOT_ENDS_WITH: ID
  name: String
  name_NOT: String
  name_IN: [String!]
  name_NOT_IN: [String!]
  name_CONTAINS: String
  name_NOT_CONTAINS: String
  name_STARTS_WITH: String
  name_NOT_STARTS_WITH: String
  name_ENDS_WITH: String
  name_NOT_ENDS_WITH: String
  password: String
  password_NOT: String
  password_IN: [String!]
  password_NOT_IN: [String!]
  password_CONTAINS: String
  password_NOT_CONTAINS: String
  password_STARTS_WITH: String
  password_NOT_STARTS_WITH: String
  password_ENDS_WITH: String
  password_NOT_ENDS_WITH: String
  email: String
  email_NOT: String
  email_IN: [String!]
  email_NOT_IN: [String!]
  email_CONTAINS: String
  email_NOT_CONTAINS: String
  email_STARTS_WITH: String
  email_NOT_STARTS_WITH: String
  email_ENDS_WITH: String
  email_NOT_ENDS_WITH: String
  roles: [String!]
  roles_NOT: [String!]
  roles_INCLUDES: String
  roles_NOT_INCLUDES: String
  createdDocumentsAggregate: UserCreatedDocumentsAggregateInput
  "Return Users where all of the related Documents match this filter"
  createdDocuments_ALL: DocumentWhere
  "Return Users where none of the related Documents match this filter"
  createdDocuments_NONE: DocumentWhere
  "Return Users where one of the related Documents match this filter"
  createdDocuments_SINGLE: DocumentWhere
  "Return Users where some of the related Documents match this filter"
  createdDocuments_SOME: DocumentWhere
  createdDocumentsConnection_ALL: UserCreatedDocumentsConnectionWhere
  createdDocumentsConnection_NONE: UserCreatedDocumentsConnectionWhere
  createdDocumentsConnection_SINGLE: UserCreatedDocumentsConnectionWhere
  createdDocumentsConnection_SOME: UserCreatedDocumentsConnectionWhere
}
"Exposes a URL that specifies the behavior of this scalar."
directive @specifiedBy(
    "The URL that specifies the behavior of this scalar."
    url: String!
  ) on SCALAR
